---
title: 'Building With Interfaces in Go'
publishedAt: '2023-09-30'
summary: 'Learn how to use interfaces in Go'
---

# Introduction

Interfaces in Go are a versatile tool that can greatly enhance the way we design and build programs. In this blog post, we’ll explore how Go interfaces can be leveraged to create a flexible and extensible system for making various types of toys.

#### The World of Toy Creation

Imagine you are developing a toy factory application in Go. Your factory can produce a wide range of toys, from teddy bears to action figures and remote-controlled cars. Each toy has its unique features and functionalities, making it challenging to design a robust and maintainable system.

#### Enter Go Interfaces

Go interfaces provide an elegant solution to handle the diversity of toy types and their respective functionalities. Let’s dive into a practical example:

```go
package main

import (
 "fmt"
)

// Toy represents the basic structure of a toy.
type Toy interface {
 Assemble() string
 Play() string
}

// TeddyBear is a type of toy that implements the Toy interface.
type TeddyBear struct {
 Name string
}

// Assemble method for a teddy bear.
func (tb TeddyBear) Assemble() string {
 return fmt.Sprintf("Assembling a %s teddy bear…", tb.Name)
}

// Play method for a teddy bear.
func (tb TeddyBear) Play() string {
 return fmt.Sprintf("Playing with the %s teddy bear!", tb.Name)
}

// ActionFigure is another type of toy that implements the Toy interface.
type ActionFigure struct {
 Name string
}

// Assemble method for an action figure.
func (af ActionFigure) Assemble() string {
 return fmt.Sprintf("Assembling an %s action figure…", af.Name)
}

// Play method for an action figure.
func (af ActionFigure) Play() string {
 return fmt.Sprintf("Playing with the %s action figure!", af.Name)
}

func main() {
 // Create a teddy bear.
 teddy := TeddyBear{Name: "Cuddly"}

// Create an action figure.
 actionFigure := ActionFigure{Name: "Superhero"}

// Create a slice of toys.
 toys := []Toy{teddy, actionFigure}

// Assemble and play with each toy.
 for _, toy := range toys {
 fmt.Println(toy.Assemble())
 fmt.Println(toy.Play())
 fmt.Println() // Add a newline for separation.
 }
}
```

In this example, we define a Toyinterface with two methods: `Assemble()` and Play(). We then create two toy types, TeddyBearand ActionFigure, each of which implements the Toyinterface by providing their implementations of Assemble()and Play(). If this wasn’t clear just to repeat myself; we use the names of the func’s as a contract to agree with; with the Interfacethat we are implementing. Moving forward any methods that use the same names are now in agreement with this Interface as to what they should now be implementing as a default. ie ActionFigure implements the Play() / Assemble() methods.

### Benefits of Using Interfaces

Using interfaces in your toy creation program offers several advantages:

1. **Flexibility** : You can create new types of toys by simply implementing the `Toy` interface. This allows you to add new toys to your factory without modifying existing code.

2. **Polymorphism** : You can treat different types of toys uniformly, enabling you to assemble and play with them generically, as demonstrated in the loop in the `main()` function.

3. **Maintainability** : Interfaces promote clean code by enforcing a consistent structure for toys. This makes it easier to understand, extend, and maintain your toy factory application.

4. **Testing** : Interfaces make it straightforward to create mock toy implementations for testing purposes, ensuring the reliability of your code.

#### Conclusion

In the world of toy creation, Go interfaces are a valuable tool for building a flexible and extensible system. By defining a common interface for different types of toys, you can streamline the assembly and play processes, making your toy factory code more elegant and maintainable. As you continue to develop your toy factory, interfaces will empower you to add new and exciting toys to your lineup with ease. Happy toy crafting in Go!